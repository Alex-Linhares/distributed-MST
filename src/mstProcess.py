# -*- generated by 1.0.12 -*-
import da
PatternExpr_439 = da.pat.TuplePattern([da.pat.ConstantPattern('connect'), da.pat.FreePattern('level'), da.pat.FreePattern('recv_id')])
PatternExpr_557 = da.pat.TuplePattern([da.pat.ConstantPattern('initiate'), da.pat.FreePattern('level'), da.pat.FreePattern('fragm_id'), da.pat.FreePattern('state'), da.pat.FreePattern('recv_id')])
PatternExpr_710 = da.pat.TuplePattern([da.pat.ConstantPattern('test'), da.pat.FreePattern('level'), da.pat.FreePattern('fragm_id'), da.pat.FreePattern('recv_id')])
PatternExpr_826 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('recv_id')])
PatternExpr_876 = da.pat.TuplePattern([da.pat.ConstantPattern('reject'), da.pat.FreePattern('recv_id')])
PatternExpr_944 = da.pat.TuplePattern([da.pat.ConstantPattern('report'), da.pat.FreePattern('best_wt'), da.pat.FreePattern('recv_id')])
PatternExpr_1105 = da.pat.TuplePattern([da.pat.ConstantPattern('change_root'), da.pat.FreePattern('recv_id')])
PatternExpr_1162 = da.pat.TuplePattern([da.pat.ConstantPattern('halt'), da.pat.FreePattern('recv_id')])
PatternExpr_1175 = da.pat.TuplePattern([da.pat.ConstantPattern('check_queue'), da.pat.FreePattern('recv_id')])
_config_object = {}
import sys
import time
INFINITY = 9999999999999999999999999

class Edge():

    def __init__(self, weight, to, state):
        self.weight = weight
        self.to = to
        self.state = state

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        return '{} -> {} -> {}'.format(self.to, self.weight, self.state)

class MSTProcess(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_0', PatternExpr_439, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_438]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_1', PatternExpr_557, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_556]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_2', PatternExpr_710, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_709]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_3', PatternExpr_826, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_825]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_4', PatternExpr_876, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_875]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_5', PatternExpr_944, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_943]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_6', PatternExpr_1105, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_1104]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_7', PatternExpr_1162, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_1161]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MSTProcessReceivedEvent_8', PatternExpr_1175, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._MSTProcess_handler_1174])])

    def setup(self, id, listOfProcesses, graphInfo, **rest_1384):
        super().setup(id=id, listOfProcesses=listOfProcesses, graphInfo=graphInfo, **rest_1384)
        self._state.id = id
        self._state.listOfProcesses = listOfProcesses
        self._state.graphInfo = graphInfo
        self._state.listOfProcesses = self._state.listOfProcesses
        self._state.edges = {}
        self._state.my_id = self._state.id
        iterator = iter(self._state.graphInfo.split(' '))
        for val in iterator:
            self._state.edges[int(val)] = Edge(int(next(iterator)), int(val), 'basic')
        self._state.level = 0
        self._state.state = 'sleeping'
        self._state.find_count = 0
        self._state.fragm_id = (- 1)
        self._state.best_edge = None
        self._state.best_wt = INFINITY
        self._state.test_edge = None
        self._state.in_branch_node = (- 1)
        self._state.terminate = False
        self._state.queue = []

    def run(self):
        self.wakeup()
        super()._label('_st_label_1266', block=False)
        _st_label_1266 = 0
        while (_st_label_1266 == 0):
            _st_label_1266 += 1
            if self._state.terminate:
                _st_label_1266 += 1
            else:
                super()._label('_st_label_1266', block=True)
                _st_label_1266 -= 1
        self.output('Node: ', self._state.my_id, ' Branch edges states = ', {k: v for (k, v) in self._state.edges.items() if (not (v.state == 'reject'))})

    def get_min_edge(self):
        a = None
        for edge in self._state.edges:
            if (not (self._state.edges[edge].state == 'basic')):
                continue
            if (a == None):
                a = self._state.edges[edge]
            elif (a.weight > self._state.edges[edge].weight):
                a = self._state.edges[edge]
        return a

    def wakeup(self):
        if (self._state.state == 'sleeping'):
            a = self.get_min_edge()
            self._state.edges[a.to].state = 'branch'
            self._state.state = 'found'
            self.send(('connect', self._state.level, self._state.my_id), to=self._state.listOfProcesses[a.to])

    def rcv_connect(self, level, recv_id):
        self.wakeup()
        if (level < self._state.level):
            self._state.edges[recv_id].state = 'branch'
            self.send(('initiate', self._state.level, self._state.fragm_id, self._state.state, self._state.my_id), to=self._state.listOfProcesses[recv_id])
            if (self._state.state == 'find'):
                self._state.find_count += 1
        elif (self._state.edges[recv_id].state == 'basic'):
            self._state.queue.append({'msg': 'connect', 'level': level, 'recv_id': recv_id})
        else:
            self.send(('initiate', (self._state.level + 1), self._state.edges[recv_id].weight, 'find', self._state.my_id), to=self._state.listOfProcesses[recv_id])

    def test(self):
        self._state.test_edge = self.get_min_edge()
        if (not (self._state.test_edge == None)):
            self.send(('test', self._state.level, self._state.fragm_id, self._state.my_id), to=self._state.listOfProcesses[self._state.test_edge.to])
        else:
            self.report()

    def rcv_test(self, level, fragm_id, recv_id):
        self.wakeup()
        if (level > self._state.level):
            self._state.queue.append({'msg': 'test', 'level': level, 'fragm_id': fragm_id, 'recv_id': recv_id})
        elif (not (fragm_id == self._state.fragm_id)):
            self.send(('accept', self._state.my_id), to=self._state.listOfProcesses[recv_id])
        else:
            if (self._state.edges[recv_id].state == 'basic'):
                self._state.edges[recv_id].state = 'reject'
            if ((self._state.test_edge == None) or (not (self._state.test_edge.to == recv_id))):
                self.send(('reject', self._state.my_id), to=self._state.listOfProcesses[recv_id])
            else:
                self.test()

    def report(self):
        if ((self._state.find_count == 0) and (self._state.test_edge == None)):
            self._state.state = 'found'
            self.send(('report', self._state.best_wt, self._state.my_id), to=self._state.listOfProcesses[self._state.in_branch_node])

    def rcv_report(self, best_wt, recv_id):
        if (not (recv_id == self._state.in_branch_node)):
            self._state.find_count -= 1
            if (best_wt < self._state.best_wt):
                self._state.best_wt = best_wt
                self._state.best_edge = self._state.edges[recv_id]
            self.report()
        elif (self._state.state == 'find'):
            self._state.queue.append({'msg': 'report', 'best_wt': best_wt, 'recv_id': recv_id})
        elif (best_wt > self._state.best_wt):
            self.change_root()
        elif ((best_wt == self._state.best_wt) and (self._state.best_wt == INFINITY)):
            self.halt(recv_id)

    def change_root(self):
        if (self._state.best_edge.state == 'branch'):
            self.send(('change_root', self._state.my_id), to=self._state.listOfProcesses[self._state.best_edge.to])
        else:
            self.send(('connect', self._state.level, self._state.my_id), to=self._state.listOfProcesses[self._state.best_edge.to])
            self._state.best_edge.state = 'branch'
            self._state.edges[self._state.best_edge.to].state = 'branch'

    def halt(self, recv_id):
        self._state.terminate = True
        for i in self._state.edges:
            if ((i == recv_id) or (not (self._state.edges[i].state == 'branch'))):
                continue
            self.send(('halt', self._state.my_id), to=self._state.listOfProcesses[i])

    def check_queue(self):
        temp_queue = []
        for i in self._state.queue:
            temp_queue.append(i)
        self._state.queue = []
        for queue_elem in temp_queue:
            if (queue_elem['msg'] == 'report'):
                self.rcv_report(queue_elem['best_wt'], queue_elem['recv_id'])
            elif (queue_elem['msg'] == 'connect'):
                self.rcv_connect(queue_elem['level'], queue_elem['recv_id'])
            elif (queue_elem['msg'] == 'test'):
                self.rcv_test(queue_elem['level'], queue_elem['fragm_id'], queue_elem['recv_id'])

    def _MSTProcess_handler_438(self, level, recv_id):
        self.rcv_connect(level, recv_id)
        self.check_queue()
    _MSTProcess_handler_438._labels = None
    _MSTProcess_handler_438._notlabels = None

    def _MSTProcess_handler_556(self, level, fragm_id, state, recv_id):
        self._state.level = level
        self._state.fragm_id = fragm_id
        self._state.state = state
        self._state.in_branch_node = recv_id
        self._state.best_edge = None
        self._state.best_wt = INFINITY
        for proc in self._state.edges:
            if ((self._state.edges[proc].to == recv_id) or (not (self._state.edges[proc].state == 'branch'))):
                continue
            self.send(('initiate', self._state.level, self._state.fragm_id, self._state.state, self._state.my_id), to=self._state.listOfProcesses[proc])
            if (self._state.state == 'find'):
                self._state.find_count += 1
        if (self._state.state == 'find'):
            self.test()
        self.check_queue()
    _MSTProcess_handler_556._labels = None
    _MSTProcess_handler_556._notlabels = None

    def _MSTProcess_handler_709(self, level, fragm_id, recv_id):
        self.rcv_test(level, fragm_id, recv_id)
        self.check_queue()
    _MSTProcess_handler_709._labels = None
    _MSTProcess_handler_709._notlabels = None

    def _MSTProcess_handler_825(self, recv_id):
        self._state.test_edge = None
        if (self._state.edges[recv_id].weight < self._state.best_wt):
            self._state.best_wt = self._state.edges[recv_id].weight
            self._state.best_edge = self._state.edges[recv_id]
        self.report()
        self.check_queue()
    _MSTProcess_handler_825._labels = None
    _MSTProcess_handler_825._notlabels = None

    def _MSTProcess_handler_875(self, recv_id):
        if (self._state.edges[recv_id].state == 'basic'):
            self._state.edges[recv_id].state = 'reject'
        self.test()
        self.check_queue()
    _MSTProcess_handler_875._labels = None
    _MSTProcess_handler_875._notlabels = None

    def _MSTProcess_handler_943(self, best_wt, recv_id):
        self.rcv_report(best_wt, recv_id)
        self.check_queue()
    _MSTProcess_handler_943._labels = None
    _MSTProcess_handler_943._notlabels = None

    def _MSTProcess_handler_1104(self, recv_id):
        self.change_root()
        self.check_queue()
    _MSTProcess_handler_1104._labels = None
    _MSTProcess_handler_1104._notlabels = None

    def _MSTProcess_handler_1161(self, recv_id):
        self.halt(recv_id)
    _MSTProcess_handler_1161._labels = None
    _MSTProcess_handler_1161._notlabels = None

    def _MSTProcess_handler_1174(self, recv_id):
        self.check_queue()
    _MSTProcess_handler_1174._labels = None
    _MSTProcess_handler_1174._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'clock': 'Lamport'}

    def run(self):
        if (len(sys.argv) < 2):
            self.output('filename missing in command')
            sys.exit(1)
        filename = sys.argv[1]
        f = open(filename, 'r')
        nproc = int(f.readline())
        topology = list(self.new(MSTProcess, num=nproc))
        listOfProcesses = {}
        for (i, p) in enumerate(topology):
            listOfProcesses[i] = p
        for (i, p) in enumerate(topology):
            self._setup(p, (i, listOfProcesses, f.readline()))
        self._start(topology)
